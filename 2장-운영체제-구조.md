# Chapter 2. 운영체제 구조
```
  1. 운영체제 서비스
  2. 사용자와 운영체제 인터페이스
  3. 시스템 콜
  4. 시스템 서비스
  5. 링커와 로더
  6. 응용 프로그램이 운영체제마다 다른 이유
  7. 운영체제 설계 및 구현
  8. 운영체제 구조
  9. 운영체제 빌딩과 부팅
  10. 운영체제 디버깅
  11. 요약
```
## Outline

- Operating System Services
- System Calls

- OS Design & Implementation

- Operating System Structure

- System Boot

## 2.1 운영체제 서비스

### 🔸사용자를 위한 서비스

- **사용자 인터페이스**(UI) : GUI(Graphic User Interface), Batch, CLI(Command User Interface), Touch-Screen UI, NUI(Natural User Interface)
- **프로그램 수행** : 시스템은 프로그램을 메모리에 적재(load)해 실행할 수 있어야한다. 
- **입출력 연산**(I/O operation) : 수행중인 프로그램은 입출력을 요구할 수 있고, 파일이나 입출력 장치가 연관될 수 있다. 
- **파일 시스템 조작** : 프로그램은 파일에 대해 읽기, 쓰기, 생성, 삭제, 검색, 정보, 접근 허가 및 거부의 기능을 가진다. 
- **통신** : 동일한 컴퓨터에서 수행되고있는 프로세스들 사이에서 일어나거나, 네트워크에 의해 묶여있는 서로 다른 컴퓨터 시스템 상에서 수행되는 프로세스들 사이에서 일어난다. 공유메모리/message passing등의 기법으로 구현된다. 
- **오류 탐지** : 운영체제는 모든 일어날 수 있는 오류를 항상 의식하고 있어아한다. 오류는 하드웨어 또는 사용자 프로그램에서 일어날 수 있다. 운영체제는 올바르고 일관성있는 계산을 보장하기 위해 오류에 대한 적당한 조처를 해야한다. 

### 🔸효율성을 위한 서비스

- **자원 할당**(resource allocator) : 다수의 프로세스나 다수의 작업이 동시에 실행될 때 , 그들 각각에 자원을 할당해주어야한다. 
- **기록 작성**(logging) : 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있도록 기록하고, 회계와 사용 통계를 낸다. 
- **보호(protection)과 보안(security)** : **보호**는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. **보안**은 자기자신을 인증하는 것부터 시작하여 부적합한 접근 시도로부터 지키고, 침입 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힌다. 시스템이 보호되고 보안이 유지되려면 시스템 전체에 걸쳐 **예방책**이 제정되어야한다. 

## 2.2 사용자와 운영체제 인터페이스

#### 2.2.1 명령 인터프리터(Command-Interpreter)

사용자가 지정한 명령을 가져와서 그것을 수행한다.

방법1 : 명령 인터프리터 자체가 명령을 실행할 코드를 가진다.

방법2 : 시스템 프로그램에 의해 대부분의 명령을 구현한다. 커맨드는 별도의 파일로 저장되어있고 쉘에서는 단지 찾아서 실행하는 방식이다. (shell script) UNIX에서 rm file.txt 명령을 내리면 내부 로직에 의해 file.txt가 삭제된다. 대부분의 경우에 사용된다. 

#### 2.2.2 그래픽 기반 사용자 인터페이스(Graphical User Interface)

마우스를 기반으로 하는 윈도 메뉴 시스템

#### 2.2.3 터치스크린 인터페이스(Touch-Screen Interface)

사용자가 터치스크린에서 터치하거나 스와이프 하는 등의 제스처를 사용

예) Ipad, IPhone의 Springboard 터치스크린 인터페이스

#### 2.2.4 인터페이스의 선택

인터페이스의 사용은 개인의 선호에 달려있다.

(주로 시스템 관리자나 파워유저들은 CLI를 선호한다.

Windows 사용자들은 Windows GUI환경을 원하고 셸 인터페이스는 거의 사용하지 않는다.

최근 Windows운영체제는 데스크톱 및 일반 랩탑용 표준 GUI와 태블릿용 터치스크린 인터페이스를 제공한다. 

역사적으로 MacOS는 GUI만 제공하고 CLI는 제공하지 않았었다. 그러나 현재는 Aqua GUI와 COI를 함께 제공한다. 

iOS및 Android 모바일 시스템에서는 CLI가 거의 사용되지 않는다. 대부분 터치스크린을 사용)

## 2.3 시스템 콜

### 2.3.1 시스템 콜

- 시스템 콜은 <u>os에게 서비스를 요청할 수 있는 메커니즘</u>이다.

- **WHEN**? 언제 시스템콜을 호출할까?
  - <u>응용프로그램이 HW에 접근할 필요가 있을 때</u> 반드시 시스템콜을 호출해야한다.
- **HOW**? 어떻게 시스템 콜을 사용할까?
  - 응용프로그램에서는 라이브러리에 포함된 시스템 콜 API를 호출한다. 
  - 시스템콜이 호출되면 OS내부의 코드가 수행되야하므로 유저모드->커널모드로 전환되고, 시스템콜이 끝나면 다시 유저모드로 전환된다. 
- (Ch1의 내용 다시보기) 듀얼모드(커널모드와 유저모드) 
  - 커널모드에 진입하는 방법에는 두 가지가 있다. 
    - 하드웨어 인터럽트 : 비동기적으로 발생. 외부 디바이스에서 발생되는 인터럽트.
    - 트랩 : 소프트웨어 인터럽트. 
      - exception
      - system call

### 2.3.2  응용 프로그래밍 인터페이스(API, Application Programming Interface)

- 대부분의 응용개발자들은 API에 따라 프로그램을 설계한다. 
- 응용 프로그래머가 흔하게 사용하는 API의 종류 
  - Windows API
  - POSIX API
  - Java API
- 응용 프로그래머는 시스템 콜을 직접 호출하는 것보다 API를 통해 간접적인 시스템 콜 호출을 한다. 
  - 자신이 프로그램이 같은 API를 지원하는 어느 시스템에건 컴파일되고 실행된다는 것을 기대할 수 있다. 
  - 실제 시스템콜은 종종 좀 더 자세한 명세가 필요하고 프로그램상에서 작업하기가 응용 프로그래머에게 가용한 API보다 더 어렵다. 

## 2.4 시스템 서비스

- 시스템 유틸리티(system utility) : 하드웨어에 접근하고, 시스템을 효과적으로 사용할 수 있도록 지원해주는 응용 레벨의 프로그램.  
  - 파일관리
  - 상태정보
  - 파일변경
  - 프로그래밍 언어지원
  - 프로그램 적재와 수행
  - 통신
  - 백그라운드 서비스
- 응용 프로그램

## 2.5 링커와 로더
## 2.6 응용 프로그램이 운영체제마다 다른 이유
## 2.7 운영체제 설계 및 구현

### 2.7.1 설계 목표

- 사용자 목적 : 사용하기 쉽고 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야한다. 
- 시스템 목적 : 설계, 생성, 유지보수가 쉬워야하며, 또한 적응성, 신뢰성, 무오류, 효율성을 가져야한다. 

### 2.7.2 기법과 정책

- Policy와 Mechanism

  - Policy : 무엇을 할 것인가? 목적
  - Mechanism : 어떤 일을 어떻게 할 것인가? (목적을 달성하기 위해 어떤 기법을 사용할 것인가)

- 예시1) 응용프로그램이 서비스를 요청할 수 있는 방법은 시스템 콜이다. 

  Policy : 응용프로그램이 서비스를 요청

  Mechanism : 이를 위해 시스템콜을 사용하는 게 이다.

- 예시2) CPU자원을 효과적으로 쓰기 위해 스케줄링이 필요하다. 

  Policy : 주기적으로 스케줄링 decision을 내려한다. 

  Mechanism : 이를 위해 주기적으로 시간을 파악할수 있어야하므로 타이머를 사용한다.

## 2.8 운영체제 구조
## 2.9 운영체제 빌딩과 부팅
## 2.10 운영체제 디버깅
## 2.11 요약
